---
title: "Automated creation of vmware server virtual machines"
author: Patrick Debois
guid: http://www.jedi.be/blog/?p=635
created_at: 2009-03-10 14:09:27.0 +00:00
blog_post: true
filter:
  - erb
  - basepath
categories:
   - Uncategorized
tags:
   - vmware-diskmanager
   - vmware
   - cobbler
   - centos
   - automation
   - pxe
---
<a href="http://www.jedi.be/blog/wp-content/uploads/2009/03/radartjes.jpg"><img title="radartjes" class="size-medium wp-image-639 alignleft" src="http://www.jedi.be/blog/wp-content/uploads/2009/03/radartjes.jpg" height="94" alt="" width="123" /></a>If you frequently want to rebuild a virtual machine, chances are that you grow tired of  going through the web interface of vmware server: after your first installation , you have to enter the bios to select booting from PXE to have higher priority then HDD boot. But if you do a PXE install then, you have to make sure that you catch the installation reboot because otherwise it will loop doing the installation.
<br>
In the following scenario we will create a vmx and vmdk file usable to start a PXE-boot.
<br>
Let's see how we can make this work via the commandline.
<br>
<strong>Create a VMX template</strong>
<br>
Just as a side note: there exist alternatives to the vmware workstation and vmware server way of creating vmx files.
<ol>
	<li><a href="http://www.easyvmx.com">Easyvmx</a> : http://www.easyvmx.com<a href="http://www.easyvmx.com">
</a></li>
	<li><a href="http://vmxbuilder.com/vmx-builder/">Vmxbuilder</a> : http://www.vmxbuilder.com</li>
	<li><a href="http://dcgrendel.thewaffleiron.net">VMBuilder</a> : http://dcgrendel.thewaffleiron.net</li>
</ol>
It turns out that none of the alternatives had the option for Redhat Enterprise Linux 5 - 64 Bit available in it's configuration.
<br>
So we used the webgui of vmware server to fit our Centos 5.2 client distribution.The most important settings in the vmx file are:
<ul>
	<li>scsi0.virtualDev = "lsilogic"</li>
	<li>scsi0:0.fileName = "&lt;our filestore&gt;/$VM_NAME/$VM_NAME.vmdk"</li>
	<li>ethernet0.virtualDev = "e1000"</li>
</ul>
<strong>Check if registered</strong>
<br>
To verify is there isn't a virtual machine already listed with our name, you can check the registered VM's
<br>
# vmrun -T server -h https://localhost:8333/sdk -u $VMWARE_USER -p $VMWARE_PASSWORD listRegisteredVM
<br>
<strong>Stop the virtual Machine</strong>
<br>
If there is one registered, stop it before we will scratch it.
<br>
# vmrun -T server -h https://localhost:8333/sdk -u $VMWARE_USER -p $VMWARE_PASSWORD stop "[standard] $VM_NAME/$VM_NAME.vmx"
<br>
<strong>Unregister the Virtual Machine </strong>
<br>
Remove it from the inventory
<br>
# vmrun -T server -h https://localhost:8333/sdk -u $VMWARE_USER -p $VMWARE_PASSWORD stop "[standard] $VM_NAME/$VM_NAME.vmx"
<br>
<strong>Remove the previous files</strong>
<br>
remove and recreate the files in the Virtual Machine location = VMWARE_PATH
<br>
# rm -rf "$VMWARE_PATH/$VM_NAME"
# mkdir -p "$VMWARE_PATH/$VM_NAME"
<br>
<strong>Re-create the virtual disk</strong>
<br>
First thing to recreate is the disk with disksize $DISK_SIZE and with the controller type that matches the VMX file we created.
<br>
# vmware-vdiskmanager  -c -s $DISK_SIZE -a $DISK_CONTROLLER -t 0 "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmdk"
<br>
$DISK_Controller has to correspond to the controller in the VMX. lsilogic for centos
<br>
"qemu-img" can be used as alternative, but it does not have an option to specify the controller type
<br>
<strong>Fix the Mac Addres </strong>
<br>
When you make a standard VMX, vmware assigns a self generated mac-address. In order to have the machine respond to the PXE-boot, we need to fix the mac address by removing the ethernet0.autogeneratedAddress and setting the addressType to 'static'.
<br>
The valid range for Mac-Addresses is : 00:50:56:00:00:00   -   00:50:56:3f:ff:ff
<br>
See <a href="http://sanbarrow.com/vmx/vmx-network-advanced.html">http://sanbarrow.com/vmx/vmx-network-advanced.html</a> for more detail.
<br>
We will get the mac-address from another source where the names and mac-addresses are managed. In our case we get it from the cobbler inventory
<br>
# MAC_ADDRESS=$(cobbler report --what=systems  --name=$VM_NAME | grep "mac address" | cut -d ':' -f 2-| sed -e 's/^ //'g)
<br>
# cat $VM_TEMPLATE | grep -v "ethernet0.addressType"| grep -v "ethernet0.generatedAddress" &gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
# echo 'ethernet0.addressType = "static"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
# echo 'ethernet0.address = "'$MAC_ADDRESS'"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
<br>
<strong>Add remote management
</strong>
<br>
To enable the remote display of a virtual machine we set the correct VNC port , so when the machine boots we can access it on VNC_PORT
<br>
# echo 'RemoteDisplay.vnc.enabled = "True"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
# echo 'RemoteDisplay.vnc.password = "$VNC_PASSWORD" &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
# echo 'RemoteDisplay.vnc.port = "'$VNC_PORT'"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
<br>
<strong>Ignore altered UID</strong>
<br>
Vmware has a way of detecting changes to virtual machines by using uuid's. For more details see <a href="http://communities.vmware.com/thread/189294">http://communities.vmware.com/thread/189294
</a>
<br>
In the VM_TEMPLATE we had:
<br>
uuid.location = "56 4d 71 ec 89 ef d7 7a-c5 6a d5 e2 8d ec 91 dd"
uuid.bios = "56 4d 71 ec 89 ef d7 7a-c5 6a d5 e2 8d ec 91 dd"
vc.uuid = "52 ae 03 1b 89 41 c3 06-9f 1a 7c 35 f8 fc 3b 30"
<br>
If we would boot our machine, the startup would hang, asking you to confirm the following:
<br>
msg.uuid.altered:This virtual machine may have been moved or copied. In order to configure certain management and networking features VMware Server needs to know which. Did you move this virtual machine, or did you copy it? If you don't know, answer "I copied it".
<br>
# echo 'uuid.action = "create"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
# echo 'msg.autoAnswer = "TRUE"' &gt;&gt; "$VMWARE_PATH/$VM_NAME/$VM_NAME.vmx"
<br>
<strong>Register the new virtual machine</strong>
# vmrun -T server -h https://localhost:8333/sdk -u $VMWARE_USER -p $VMWARE_PASSWORD register "[standard] $VM_NAME/$VM_NAME.vmx"
<br>
<strong>Start the new virtual machine</strong>
<br>
# vmrun -T server -h https://localhost:8333/sdk -u $VMWARE_USER -p $VMWARE_PASSWORD start "[standard] $VM_NAME/$VM_NAME.vmx"
<br>
<strong>Installation starts over PXE
</strong>
<br>
If the Cdrom and Harddisk do not contain any operating system, the default for a vmware machine is to try to do a PXE boot over the network, which will start the installation and after a reboot you will get your system booting from the HDD install.
<br>
You can follow the installation using a VNC client to connect to the virtual machine booting on VNC_PORT
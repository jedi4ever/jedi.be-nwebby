---
title: "Java Servlets and Large, Large file Uploads: enter apache fileupload"
author: Patrick Debois
guid: https://www.jedi.be/blog/?p=708
created_at: 2009-04-10 17:33:50.0 +00:00
blog_post: true
categories:
   - Uncategorized
tags:
   - large files
   - java
   - buffered
   - file upload
   - large upload
   - servlets
   - apache
   - nio
---
<p><a href="https://www.jedi.be/blog/2009/04/10/rails-and-large-large-file-uploads-looking-at-the-alternatives/">Having examined the rails alternatives for large file upload</a>, we turned towards other alternatives and YES , did we find one!
<br>
It's the java <a href="http://commons.apache.org/fileupload">fileupload component from the apache commons project</a>. It has the following features:<a href="https://www.jedi.be/blog/wp-content/uploads/2009/04/green-mountain-waterfall.jpg"><img title="green-mountain-waterfall" class="right" src="https://www.jedi.be/blog/wp-content/uploads/2009/04/green-mountain-waterfall-300x285.jpg" height="252" alt="" width="264" /></a>
<ul>
	<li>you can control the memory size within your servlet</li>
	<li>you have direct access to the incoming stream without any temporary file</li>
	<li>you have a streaming api for processing the different multipart streams</li>
</ul>
This document describes you to use:
<ul>
	<li> the non-streaming API</li>
	<li>the streaming version</li>
	<li>the streaming version + combinations of writing FileIO using various buffers.</li>
</ul>
</p>

<p>
<h3 class="clearfix">The basic example:( non streaming)</h3>

As described in <a href="http://commons.apache.org/fileupload/using.html">http://commons.apache.org/fileupload/using.html</a>
You can specify &lt;yourMaxMemorySize&gt;, &lt;yourTempDirectory&gt;, &lt;yourMaxRequestSize&gt;

```java
// Create a factory for disk-based file items
DiskFileItemFactory factory = new DiskFileItemFactory();
// Set factory constraints
factory.setSizeThreshold(yourMaxMemorySize);
factory.setRepository(yourTempDirectory);
// Create a new file upload handler
ServletFileUpload upload = new ServletFileUpload(factory);

// Set overall request size constraint
upload.setSizeMax(yourMaxRequestSize);

// Parse the request
List /* FileItem */ items = upload.parseRequest(request);
```


Processing the items is easy. And check if it a file part
```java
// Process the uploaded items
Iterator iter = items.iterator();
while (iter.hasNext()) {
 FileItem item = (FileItem) iter.next();
 if (item.isFormField()) {
      processFormField(item);
 } else {
     processUploadedFile(item);
 }
}
```

You access the file characteristics like this:
```java
// Process a file upload
if (!item.isFormField()) {
     String fieldName = item.getFieldName();
     String fileName = item.getName();
     String contentType = item.getContentType();
     boolean isInMemory = item.isInMemory();
     long sizeInBytes = item.getSize();
    ...
}
````

default implementation of FileUpload, write()  will attempt to rename the file to the specified destination, but if you want you can read the stream directly.
```java
// Process a file upload
if (writeToFile) {
 File uploadedFile = new File(...);
          item.write(uploadedFile);
} else {
       InputStream uploadedStream = item.getInputStream();
        ...
 uploadedStream.close();
}
```

<span>The streaming API:</span>
<br>
As described in <a href="http://commons.apache.org/fileupload/streaming.html">http://commons.apache.org/fileupload/streaming.html
</a>fileupload provides a way to avoid the write to disk before your servlet can handle.

```java
// Check that we have a file upload request
boolean isMultipart = ServletFileUpload.isMultipartContent(request);
```

Now we are ready to parse the request into its constituent items. Here's how we do it:

```// Create a new file upload handler
ServletFileUpload upload = new ServletFileUpload();
// Parse the request
FileItemIterator iter = upload.getItemIterator(request);
while (iter.hasNext()) {
      FileItemStream item = iter.next();
     String name = item.getFieldName();
     InputStream stream = item.openStream();
     if (item.isFormField()) {
               System.out.println("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
     } else {
              System.out.println("File field " + name + " with file name " + item.getName() + " detected.");
              // Process the input stream
              ...
     }
}
```

<span>How to write is to disk most efficiently:</span>
<br>
We're allmost there. Now that we have the name, the stream we can write it to the correct place on this, without tempfiles and overloaded memory!
<br>
<a href="http://java.sun.com/docs/books/performance/1st_edition/html/JPIOPerformance.fm.html">http://java.sun.com/docs/books/performance/1st_edition/html/JPIOPerformance.fm.html</a> describes different ways you can use to write your file to disk
<br>
<strong>Option 1 :</strong> The naive way, we take the inputstream and write it byte per byte to an outputstream.

```java
FileOutputStream fout= new FileOutputStream (yourPathtowriteto);
int byte_;
while ((byte_=stream.read()) != -1)
{
    fout.write(byte_);
}
fout.close();
```

<strong>Option 2</strong>: We use bufferstreams to do the job

```java
FileOutputStream fout= new FileOutputStream ( yourPathtowriteto );
BufferedOutputStream< bout= new BufferedOutputStream (fout);
BufferedInputStream bin= new BufferedInputStream(stream);

int byte_;
while ((byte_=bin.read()) != -1)
{
     bout.write(byte_);
}
bout.close();
bin.close();
```

<span>Option 3</span>: Use a byte array instead of per byte. You can experiment with different buffersize to see the effect. This depends on your filesystem blocksize and your disk cache size and so on.
<p></p>
<p></p>


```java
 FileOutputStream fout= new FileOutputStream (yourPathtowriteto);
 BufferedOutputStream bout= new BufferedOutputStream (fout);
 BufferedInputStream bin= new BufferedInputStream(stream);
 byte buf[] = new byte[2048]>;
 while ((bin.read(buf)) != -1)
 {
     bout.write(buf);
 }
 bout.close();
bin.close();
```


<strong>Option 4</strong>: Using a *static* byte array: to avoid reallocation , we create a final buffer and use synchronized to control access to it.
<br>
Again experiment with the buffersize

```java
static final> int BUFF_SIZE = 100000;
 static final byte[] buffer = new byte[BUFF_SIZE];

 FileOutputStream fout= new FileOutputStream (yourPathtowriteto);
 while (true) {
       synchronized (buffer) {
            int amountRead = stream.read(buffer);
            if (amountRead == -1) {
                  break;
            }
        fout.write(buffer, 0, amountRead);
      }
 }
 ```

<span>Controlling network I/O in your appserver</span>
<br>
We optimized our file writing. But we can also improve our network handling.
<br>
You can look at grizzly, glassfish, or jetty to use the NIO capabilities of Java.